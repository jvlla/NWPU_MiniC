--------------------------------------------------------------------------------
已废弃，当初实在是太天真了
--------------------------------------------------------------------------------
时间安排：
看起来可能很不行，使劲干吧
周一 整体计划，读懂文法，开始搞词法
周二 搞定词法分析，确认没错，搞那些节点类
周三 搞定节点类，能建出树
周四 能弄出中间表达式
周五 

文件：
lexer.l         进行词法分析
parser.y        进行语法分析，构建抽象语法树,生成相对应的符号表
main.c          主函数，读入文件，调用语法分析，返回抽象语法树、符号表，
                使用grahpviz绘制抽象语法树，生成输出四元式
SymTable.h
SymTable.cpp    符号表
    s_count_    用于计算符号表个数
                符号表项：标识符、唯一ID、类型、代码行、是否覆盖
                指向上一符号表的指针
    find(string )
Type.h
Type.cpp        类型
Array.h
Array.cpp       数组类型
SynTree.h
SynTree.cpp     抽象语法树
                包含从文法开始节点的全部树状节点
    p_node_     指向顶节点指针
    gen_ir()
    gen_graph()
SynNode.h
SynNode.cpp     抽象语法树中节点,抽象类
    s_label_    用于创建唯一的、用于转跳的标签
    s_count_    用于计算节点数
    p_parent_   指向父节点的指针
    line_       节点所在代码行
    set_parent(SynNode * p_node)    用于设置父节点的函数
    gen_ir()    遍历的时候要开始换符号表，结束换回符号表
    emit_ir()
    emit_label()
    gen_graph()
    emit_graph()
可选部分，有时间就弄
    traverse()  遍历树，参数是函数指针
各种节点         继承SynNode

每个表达式都先要判断是否符合类型定义

全局变量：
统统都是指针，免得函数栈释放了没法用
p_curr_sym_table  目前符号表，要确保之后也能有指针指向
p_ir_table        输出四元式

命名：
常量        全大写下划线
变量        小写下划线
指针变量     p开头小写下划线
成员变量    小写下划线，以下划线结尾
静态成员变量 s开头小写下划线，以下划线结尾
函数名      小写下划线
类名        大写无下划线

写代码注意：
1.为了让语法树在之后还能正确存在，类都用Box * pb = new Box(); delete pt; 创建释放
%token 是终结符，
%token <strval> items <>里面的是终结符类型
%type <integer> INTEGER <>里面的是非终结符类型
<>里面是%union中的东西

a: ε|b a 就是从最后一个b递归返回遍历          这个需要返回值，构造数组之类的类型
a: ε|a b 就是从第一个b开始遍历                 这个就不要返回了，不是递归那样，是用于顺序执行语句

有纯虚函数的类不能实例化，想要函数有多态等特性就要虚函数
node节点的名字是N几几

所有的对象、数组什么的都要指针或者malloc分配