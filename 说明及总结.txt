写给将来的我自己（如果还会看的话，其实不会了，写的实在烂）或者以后的学弟学妹（好像有点可能，看有没有人找华文要吧）

自我介绍：
乐浩天，2018302336，嗯，如果是女同学，有兴趣加个QQ什么的？ 2727546814
虽然根据我对子平的研究，22年应该找到女朋友了，也不太应该是学妹，但，万一呢！

使用：
系统需要--
安装有flex, bison和graphviz软件并具有c++编译环境的Linux系统中
（我是在Windows WSL中的Ubuntu20.04里做的，这个要装flex, bison的话用“sudo apt-get install flex bison”命令，
  要安gcc的话应该是用"sudo apt-get install build-essential"命令吧，反正记得有点坑）
编译--
make
产生出的可执行文件为compiler_haotian
（这个是有点问题的，make的依赖没有弄明白怎么搞，所以一些文件变化时另一些需要重新编译是做不到了，可能会有奇怪
报错，所以需要make clean后重新make）
运行--
./compiler_haotian 代码文件
或sh test.sh additional|basic|error|optional 可以分别运行miniC_test_cases中的基本、附加、错误、可选测试
（其实这个没什么用，大概只肯定能过基本测试、勉强能过错误测试产生点报错（没太注意报错），剩下的就很难或基本不行了）
调试--
common.h头文件中如果不注释#define DEBUG可以输出一些调试信息帮助找错

问题：
无法翻译有重复变量名的程序（比如两个a在不同函数, int a和函数a），很难解决，符号表设计时老师还没过那个测试用例，
所以就简化了命名重复问题，再想改可能要完全重新设计符号表部分了
（注释掉SymTable.cpp的15、16行解决，报错了就解决报错的代码嘛，但所有同名变量就都不会报错了（就算一个函数里也是），
  交代码记得删）
无法翻译二维及以上数组等，很难解决，文法倒是好改，但语法树节点加上这个比较麻烦，最后赶时间写的代码更大大加剧了难度

修改建议：
    不建议修改……确实，结束后再回顾设计很多不合理的地方，比如Terminal没有继承Expr、各个类保存的信息很不统一、
比如gen_ir()等函数的参数、返回值不适合进行函数调用等，反正很多地方，而且牵扯的地方太多都不太好改了。
    如果确实要修改的话，推荐从git里找前几个版本，到翻译函数调用、数组部分之前。后面这些时间太赶了基本就是能用
就行所以代码根本没法看了。
    当然，更建议作为参考，比如我觉得SynNode继承分为Stmt和Expr（虽然是从课本里给的代码学来的），还有gen_graph()
调用get_node_content()什么的一些部分设计的还是挺好的。

经验教训：
一定要做好充足的规划！！！
    我是想了一天多就开始做，当初实在没想到这事情要干快一个月，所以很多部分最开始划分的就有问题。应该至少计划
四五天吧，功能分的详细一点，到底需要哪些类（弄明白所有可能需要的类，这个后面再添太影响整体设计了）、每个类都
需要什么函数、类与类之间的接口（其实就是函数名了，没那么高级），还有类与类的继承关系想明白。
    总而言之，这程序到最后确实趋于崩溃状态，行数太多还是有点超出我现在的能力范围（尤其是开始时错误的以为只要
大概2000行就能搞定），确实是《软件工程》课上讲的失败类型。
    但总体而言，还是很有成就感的，亲手把自己的设想实现，完成了最开始可以说无从下手的任务。当然，过程还是挺痛
苦的，看着大概五点钟西工大慢慢变亮差不多要有十次了，但最后弄出来的时候，是真的开心，有些找回我初二时候第一次
写出hello world的，初心吧。

行数统计：
.cpp        1963
.h           808
lexer.l       98
parser.y    1098
Makefile      74
total       4041

抽象语法树、符号表类间继承关系：
SynTree部分--
                                 SynNode                                                            
   _________________________________|____________________________________                           
  |                  |                          |                        |                          
Block              Stmt                       Expr                   Terminal                       
  |    ______________|_______________      _____|_____          _________|_________                 
  |   |   |    |     |       |       |    |   |       |        |        |          |                
Func If Else While Break Continue Return Op Unary FuncCall Variable Constant TempVariable           
SynTree部分其他--
SynTree Operator SynTreeException
SymTable部分--
       Type       
     ____|___     
    |        |    
TypeFunc TypeArray
SymTable部分其他--
SymTable SymTableException
各部分用途--
太麻烦，不太想写了，望类名生义吧，注释也可以凑合看看。

词法、语法和主程序等文件：
lexel.l LexerException.h LexerException.cpp                     词法分析及相应异常
parser.y help.h help.cpp ParserException.h ParserException.cpp  语法分析和辅助文件及相应异常
QuadTable.h QuadTable.cpp                                       四元式表
main.cpp                                                        主程序

思路及函数说明：
要写起来内容很多，但实验结束实在太疲惫，不想碰代码，随便说说吧。
思路--
在lexer.y中进行词法分析，在parser.y中进行语法分析进而生成符号表和抽象语法树，最后遍历抽象语法树生成四元式
函数说明--
词法分析，
这个主要比较零碎了，函数、变量定义部分用了一些定义在help.h中的结构体传需要的参数，然后填写符号表
在表达式、语句等的产生式归约过程中产生新的节点并连接，最终形成一颗树
抽象语法树，
主要讲讲把树画出来的函数和生成四元式函数吧。
gen_graph()
用途：生成.dot文件在之后可以调用graphviz软件产生图
实现：首先调用emit_node()和emit_link()函数，产生当前节点和当前节点和前驱节点的连线（这个是少有的我觉得设计很
      满意的地方），这一步是在SynNode::gen_graph()中完成之后再根据子节点的不同，用不同方式遍历子节点。
      总而言之，深度优先搜索。
gen_ir()
用途：在QuadTable对象中添加由本节点产生的新的四元式
实现：同样是深度优先搜索，不同在于对函数返回值进行了利用。返回了指向Terminal对象的指针，这个是子节点四元式产
      生的值，比如a = b + 1; 翻译为(+, b, 1, t1) (=, t1, -, a) (=, a, -, t2)，这个Terminal对象的指针调
      用to_string()函数返回值就是t2，当然常量、变量就返回的是自身了，具体看代码理解吧。要额外说明的地方是，
      做数组部分的时候，只有最后一天了，就没把数组变量从Variable类里面继承出来，所以在Op类中翻译的时候就很
      混乱，尤其是相同的部分都没弄出个函数来。
